\name{tam.mml}

\alias{tam}
\alias{tam.mml}
\alias{tam.mml.2pl}
\alias{tam.mml.mfr}
\alias{summary.tam}
\alias{summary.tam.mml}


\title{
Test Analysis Modules: Marginal Maximum Likelihood Estimation
}
\description{
Modules for psychometric test analysis demonstrated 
  with the help of artificial example data. 
  The package includes MML and JML estimation of 
  uni- and multidimensional IRT (Rasch,  2PL, Generalized Partial 
  Credit, Rating Scale, Multi Facets) 
  models, fit statistic computation, standard error estimation, as 
  well as plausible value imputation and weighted likelihood
  estimation of ability. 
}

%  Wrapper and outlining methods (S3, wrapper, plot, print, summary) 
%  are still to come.


\usage{
tam(resp , irtmodel ="1PL" , formulaA=NULL, ...)

tam.mml(resp, Y = NULL, group = NULL, irtmodel = "1PL", formulaY = NULL,
    dataY = NULL, ndim = 1,  pid = NULL, xsi.fixed = NULL, xsi.inits = NULL, 
    beta.fixed = NULL, beta.inits = NULL, variance.fixed = NULL, 
    variance.inits = NULL, est.variance = FALSE, A = NULL, B = NULL, 
    B.fixed = NULL,  Q = NULL,  est.slopegroups = NULL, E = NULL, 
    pweights = NULL, control = list())

tam.mml.2pl(resp, Y = NULL, group = NULL, irtmodel = "2PL", formulaY = NULL, 
    dataY = NULL, ndim = 1, pid = NULL, xsi.fixed = NULL, xsi.inits = NULL,
    beta.fixed = NULL, beta.inits = NULL, variance.fixed = NULL, 
    variance.inits = NULL, est.variance = FALSE, A = NULL, B = NULL, 
    B.fixed = NULL, Q = NULL, est.slopegroups = NULL, E = NULL, 
    pweights = NULL, control = list())
            
tam.mml.mfr(resp, Y = NULL, group = NULL, irtmodel = "1PL", formulaY = NULL,
    dataY = NULL, ndim = 1, pid = NULL, xsi.fixed = NULL, xsi.inits = NULL, 
    beta.fixed = NULL, beta.inits = NULL, variance.fixed = NULL , 
    variance.inits = NULL , est.variance = FALSE , formulaA=~item+item:step, 
    constraint="cases", A=NULL , B=NULL ,  B.fixed = NULL , Q=NULL , 
    facets=NULL, est.slopegroups=NULL , E = NULL , pweights = NULL , 
    control = list() , delete.red.items=TRUE )
    
\method{summary}{tam}(object,file=NULL,\dots)

\method{summary}{tam.mml}(object,file=NULL,\dots)    
}
%% USAGE
%%tam.jml(resp, group = NULL, disattenuate = FALSE, bias = TRUE, 
%%    xsi.fixed = NULL, xsi.inits = NULL,  A = NULL, B = NULL, Q = NULL, 
%%    R = NULL, ndim = 1, pweights = NULL, control = list())

%%tam.jml2(resp, group = NULL, disattenuate = FALSE, bias = TRUE, 
%%    xsi.fixed = NULL, xsi.inits = NULL,  A = NULL, B = NULL, 
%%    Q = NULL, R = NULL, ndim = 1, pweights = NULL, control = list())

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% ARGUMENTS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%- maybe also 'usage' for other objects documented here.
\arguments{
  \item{resp}{
     Data frame with polytomous item responses \eqn{k=0,...,K}.
     Missing responses must be declared as \code{NA}.
}
  \item{Y}{
     A matrix of covariates in latent regression. Note that the
     intercept is automatically included as the first predictor.
}
  \item{group}{
     An optional vector of group identifiers
}
  \item{irtmodel}{
     For fixed item slopes (in \code{tam.mml}) 
     options include \code{PCM} (partial credit model), \code{PCM2} 
     (partial credit model with ConQuest parametrization 
     \code{'item+item*step'} and \code{RSM} (rating scale model; 
     the ConQuest parametrization \code{'item+step'}). \cr
     For estimated item slopes (in \code{tam.mml.2pl})
     options are \code{2PL} (all slopes of item categories
     are estimated), \code{GPCM} (generalized partial credit
     model in which every item gets one and only slope
     parameter per dimension) and \code{2PL.groups}
     (subsets of items get same item slope estimates)
     and a design matrix \code{E} on item slopes in the
     generalized partial credit model (\code{GPCM.design},
     see Examples). 
     Note that item slopes can not be estimated with faceted
     designs using the function \code{tam.mml.mfr}. However,
     it is easy to use pre-specified design matrices and apply
     some restrictions to \code{tam.mml.2pl} (see Example 14, Model 3).
}
  \item{formulaY}{
     An \R formula for latent regression. Transformations of predictors
     in \eqn{Y} (included in \code{dataY}) can be easily spcified,
     e. g. \code{female*race} or \code{I(age^2)}.
}
  \item{dataY}{
     An optional data frame with possible covariates \eqn{Y} in latent regression.
     This data frame will be used if an \R formula in \code{formulaY}
     is specified.
}
  \item{ndim}{
     Number of dimensions (is not needed to determined by the user)
}
  \item{pid}{
     An optional vector of person identifiers
}
  \item{xsi.fixed}{
     A matrix with two columns for fixing \eqn{\xi} parameters. 
     1st column: index of \eqn{\xi} parameter, 2nd column: fixed value 
}
  \item{xsi.inits}{
     A matrix with two columns (in the same way defined as in
     \code{xsi.fixed} with initial value for \eqn{\xi}.
}
  \item{beta.fixed}{
     A matrix with three columns for fixing regression coefficients.
     1st column: Index of \eqn{Y} value, 2nd column: dimension,
     3rd column: fixed \eqn{\beta} value. \cr
     If no constraints should be inposed on \eqn{\beta}, then
     set \code{beta.fixed=FALSE} (see Example 2, Model \code{2_4}).
}
  \item{beta.inits}{
     A matrix (same format as in \code{beta.fixed}) 
     with initial \eqn{\beta} values
}
  \item{variance.fixed}{
     An optional matrix with three columns for fixing
     entries in covariance matrix:
     1st column: dimension 1, 2nd column: dimension 2,
     3rd column: fixed value
}
  \item{variance.inits}{
     Initial covariance matrix in estimation. All matrix entries have to be
     specified and this matrix is NOT in the same format like
     \code{variance.inits}.
}
  \item{est.variance}{
     Should the covariance matrix be estimated? This argument
     applies to estimated item slopes in \code{tam.mml.2pl}.
     The default is \code{FALSE} which means that latent
     variables (in the first group) are standardized in 2PL estimation.
}
\item{constraint}{Set sum constraint for parameter identification 
	for \code{items} or \code{cases} (applies to \code{tam.mml.mfr})
	}
  \item{A}{
     An optional array of dimension \eqn{ I \times (K+1) \times N_\xi}.
     Only \eqn{\xi} parameters are estimated, entries in \eqn{A}
     only correspond to the design.
}
  \item{B}{
     An optional array of dimension \eqn{ I \times (K+1) \times D}.
     In case of \code{tam.mml.2pl} entries of the \eqn{B} matrix can be 
     estimated.
}
  \item{B.fixed}{
  An optional matrix with four columns for fixing \eqn{B} matrix entries in 2PL estimation.
  1st column: item index, 2nd column: category, 3rd column: dimension,
  4th column: fixed value.
}
  \item{Q}{
  An optional \eqn{I \times D} matrix (the Q-matrix) which specifies the 
  loading structure of items on dimensions.  
}
  \item{est.slopegroups}{
  A vector of integers of length \eqn{I} for estimating item slope
  parameters of item groups. This function only applies to
  the generalized partial credit model \cr (\code{irtmodel="2PL.groups"}).
}
  \item{E}{
     An optional design matrix for estimating item slopes
     in the generalized partial credit model (\code{irtmodel="GPCM"})
}
  \item{pweights}{
     An optional vector of person weights
}
\item{formulaA}{Design formula (only applies to \code{tam.mml.mfr}). 
    See Example 8.}
    
\item{facets}{A data frame with facet entries (only applies to 
	\code{tam.mml.mfr})
		}
  \item{control}{
  A list of control arguments for the algorithm: \cr\cr
  \code{ list( nodes = seq(-6,6,len=21) , snodes = 0 , QMC=TRUE,}\cr
    \code{        convD = .001 ,conv = .0001 , convM = .0001 , Msteps = 4 ,   }\cr
    \code{        maxiter = 1000 , max.increment = 1 , }\cr
    \code{        min.variance = .001 , progress = TRUE , ridge=0 ,    }\cr
    \code{        seed = NULL , xsi.start0=FALSE, , increment.factor=1 ,  }\cr
    \code{        fac.oldxsi=0 )  }\cr
    
\code{nodes}: the discretized \eqn{\theta} nodes for numerical integration 

\code{snodes}: number of simulated \eqn{\theta} nodes for stochastic integration. 
    If \code{snodes=0}, numerical integration is used. 

\code{QMC}: A logical indicating whether quasi Monte Carlo integration
   (Pan & Thomas, 2007) should be used. The default is \code{TRUE}. 
Quasi Monte Carlo integrationn is a nonstochastic integration approach 
but prevents the very demanding numeric integration using Gaussian quadrature. 
In case of \code{QMC=FALSE}, "ordinary" stochastic integration is used 
(see the section \emph{Integration} in Details).


\code{convD}: Convergence criterion for deviance

\code{conv}: Convergence criterion for item parameters and regression
coefficients

\code{convM}: Convergence criterion for item parameters within each
M step

\code{Msteps}: Number of M steps for item parameter estimation

\code{maxiter}: Maximum number of iterations

\code{max.increment}: Maximum increment for item parameter change for
every iteration

\code{min.variance}: Minimum variance to be estimated during iterations.

\code{progress}: A logical indicating whether computation progress should
be displayed at \R console

\code{ridge}: A numeric value or a vector of ridge parameter(s) 
for the latent regression which is added to the covariance matrix
\eqn{Y'Y} of predictors in the diagonal.

\code{seed}: An optional integer defining the simulation seed 
(important for reproducible results for stochastic integration) 

\code{xsi.start0}: A logical indicating whether all \eqn{\xi} starting 
values should be initially set to zero.
   
\code{increment.factor}: A value (larger than one) 
	which defines the extent of the decrease of the maximum
	increment of item parameters in every iteration. The maximum increment 
	in iteration \code{iter} is defined as 
	\code{max.increment*increment.factor^(-iter)}
	where \code{max.increment=1}. Using a value larger than 1 helps
        to reach convergence in some non-converging analyses (see Example 12). 

\code{fac.oldxsi}: An optional numeric value \eqn{f} between 0 and 1 which 
defines the weight of parameter values in previous iteration. If \eqn{\xi_t}
denotes a parameter update in iteration \eqn{t}, \eqn{\xi_{t-1}} is the
parameter value of iteration \eqn{t-1}, then the modified parameter value
is defined as \eqn{ \xi_t^* = (1-f) \cdot \xi_t + f \cdot \xi_{t-1}}.
Especially in cases where the deviance increases, setting the parameter
larger than 0 (maybe .4 or .5) is helpful in stabilizing the algorithm
(see Example 15). \cr
        
}
\item{delete.red.items}{An optional logical indicating whether redundant
	generalized items (with no observations) should be eliminated.
		}
  \item{object}{
Object of class \code{tam} or \code{tam.mml} (only for \code{summary.tam}
functions)
}
\item{file}{
A file name in which the summary output will be written 
(only for \code{summary.tam} functions)
    }
\item{\dots}{
	Further arguments to be passed
	}   
}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% DETAILS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\details{
The multidimensional item response model in \pkg{TAM} is
described in Adams, Wilson and Wu (1997) or Adams and Wu (2007).

The data frame \code{resp} contains item responses of \eqn{N} persons (in rows) 
at \eqn{I} items (in columns), each item having at most
\eqn{K} categories \eqn{k=0,...,K}.
The item reponse model has \eqn{D} dimensions of the \eqn{\theta} ability
vector and can be written as
\deqn{ 
        P( X_{pi} = k | \theta_p )  \propto exp( b_{ik} \theta_p + a_{ik} \xi ) 
        }
The symbol \eqn{\propto } means that response probabilities are normalized such
that \eqn{ \sum _k P( X_{pi} = k | \theta_p ) = 1 }.

Item category thresholds for item \eqn{i} in category \eqn{k} 
are written as a linear combination
\eqn{a_i \xi} where the vector \eqn{\xi} of length \eqn{N_\xi}
contains generalized item parameters and 
\eqn{A= ( a_{ik} )_{ik} = ( a_i )_{i} } is 
a three-dimensional design array (specified in \code{A}).

The scoring vector \eqn{b_{ik}} contains the fixed (in \code{tam.mml})
or estimated (in \code{tam.mml.2pl}) scores of item \eqn{i} in category \eqn{k}
on dimension \eqn{d}.

For \code{tam.mml.2pl} and \code{irtmodel="GPCM"}, item slopes \eqn{a_i} can be
written as a linear combination \eqn{a_i = ( E \gamma)_i } 
of basis item slopes which is an analogue
of the LLTM for item slopes (see Example 7; Embretson, 1999).

The latent regression model regresses the latent trait \eqn{\theta_p}
on covariates \eqn{Y} which results in
\deqn{ 
    \theta_p = Y \beta + \epsilon_p , \epsilon_p \sim N_D ( 0 , \Sigma )
}{%
  \theta_p = Y \beta + \epsilon_p , \epsilon_p ~ N_D ( 0 , \Sigma )
    }

Where \eqn{\beta} is a \eqn{N_Y} times \eqn{D} matrix of regression
coefficients for \eqn{N_Y} covariates in \eqn{Y}.

The multiple group model for groups 
\eqn{g=1,...,G} is only implemented for unidimensional item
response models. In this case, variance heterogeneity is allowed
\deqn{ 
    \theta_p = Y \beta + \epsilon_p , \epsilon_p \sim N ( 0 , \sigma_g^2 )
}{%
  \theta_p = Y \beta + \epsilon_p , \epsilon_p ~ N( 0 , \sigma_g^2 )
    }    
    
\bold{Integration}: Uni- and multidimensional integrals are approximated by
posing a uni- or multivariate normality assumption. The default is Gaussian
quadrature with nodes defined in \code{control$nodes}. For \eqn{D}-dimensional
IRT models, the \eqn{D}-dimensional cube consisting of the vector
\code{control$nodes} in all dimensions is used. If the user specifies 
\code{control$snodes} with a value larger than zero, then Quasi-Monte Carlo
integration (Pan & Thomas, 2007) with \code{control$snodes} is used
(because \code{control$QMC = TRUE} is set by default). If 
\code{control$QMC=FALSE} is specified, then stochastic (Monte Carlo) integration
is employed with \code{control$snodes} stochastic nodes.
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% VALUES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\value{
A list with following entries:

\item{xsi}{Vector of \eqn{\xi} parameter estimates and their
corresponding standard errors}
\item{xsi.facets}{Data frame of \eqn{\xi} parameters and corresponding
constraints for multifacet models}
\item{beta}{Matrix of \eqn{\beta} regression coefficient estimates}
\item{variance}{Covariance matrix. In case of multiple groups, 
    it is a vector indicating heteroscedastic variances}
\item{item}{Data frame with item parameters}
\item{person}{Matrix with person parameter estimates. 
    \code{EAP} is the mean of the posterior distribution and \code{SD.EAP} 
    the corresponding standard deviation
        }
\item{pid}{Vector of person identifiers}
\item{EAP.rel}{EAP reliability}
\item{post}{Posterior distribution for item response pattern}
\item{rprobs}{A three-dimensional array with estimated response probabilities
        (dimensions are items \eqn{\times} categories \eqn{\times}
      theta length)}
\item{itemweight}{Matrix of item weights}
\item{theta}{Theta grid}
\item{n.ik}{Array of expected counts: theta class \eqn{\times} 
item \eqn{\times} category \eqn{\times} group}
\item{pi.k}{Marginal trait distribution at grid \code{theta}} 
\item{Y}{Matrix of covariates}
\item{resp}{Original data frame}
\item{resp.ind}{Response indicator matrix}
\item{group}{Group identifier}
\item{G}{Number of groups}
\item{formulaY}{Formula for latent regression}
\item{dataY}{Data frame for latent regression}
\item{pweights}{Person weights}
\item{time}{Computation time}
\item{A}{Design matrix \eqn{A} for \eqn{\xi} parameters}
\item{B}{Fixed or estimated loading matrix}
\item{se.B}{Standard errors of \eqn{B} parameters}
\item{nitems}{Number of items}
\item{maxK}{Maximum number of categories}
\item{AXsi}{Estimated item intercepts \eqn{ a_{ik} \xi}}
\item{AXsi_}{Estimated item intercepts -\eqn{ a_{ik} \xi}.
Note that in \code{summary.tam}, the parameters \code{AXsi_}
are displayed.
}
\item{se.AXsi}{Standard errors of \eqn{a_{ik} \xi} parameters}
\item{nstud}{Number of persons}
\item{resp.ind.list}{List of response indicator vectors}
\item{hwt}{Individual posterior distribution}
\item{ndim}{Number of dimensions}
\item{xsi.fixed}{Fixed \eqn{\xi} parameters}
\item{beta.fixed}{Fixed \eqn{\beta} parameters}
\item{formulaA}{Design formula (only applies to \code{tam.mml.mfr})}
\item{facets}{Data frame with facet entries (only applies to \code{tam.mml.mfr})}
\item{variance.fixed}{Fixed covariance matrix}
\item{nnodes}{Number of theta nodes}
\item{deviance}{Final deviance}
\item{ic}{Vector with information criteria}
\item{deviance.history}{Deviance history in iterations}
\item{control}{List of control arguments}
% \item{design}{Output produced by \code{designMatrices} or
% \code{designMatrices.mfr}}
\item{\dots}{Further values}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% REFERENCES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\references{
Adams, R. J., Wilson, M., & Wu, M. (1997).
Multilevel item response models: An approach to errors in
variables regression. \emph{Journal of Educational and Behavioral 
Statistics}, \bold{22}, 47-76.

Adams, R. J., & Wu, M. L. (2007). The mixed-coefficients multinomial logit model.
A generalized form of the Rasch model. In M. von Davier & C. H. Carstensen (Eds.):
\emph{Multivariate and mixture distribution Rasch models: Extensions and applications}
(pp. 55-76). New York: Springer.

Embretson, S. E. (1999). Generating items during testing: 
Psychometric issues and models. \emph{Psychometrika}, \bold{64}, 407-433.

Pan, J., & Thompson, R. (2007). Quasi-Monte Carlo estimation in
generalized linear mixed models. \emph{Computational Statistics &
Data Analysis}, \bold{51}, 5765-5775.

Wu, M. L., Adams, R. J., Wilson, M. R. & Haldane, S. (2007).
\emph{ACER ConQuest Version 2.0}. Mulgrave.
\url{https://shop.acer.edu.au/acer-shop/group/CON3}
}

%\author{
%\pkg{TAM} authors
%}

\note{
For more than three dimensions, quasi-Monte Carlo or stochastic integration
is recommended because otherwise problems in memory allocation and large
computation time will result. Choose in \code{control} a suitable value of 
the number of quasi Monte Carlo or stochastic nodes \code{snodes} 
(say, larger than 1000). See Pan and Thompson (2007) for more details.
}

%\section{Warning}{
%Be cautious when using the number of estimated parameters in \code{ic}.
%Extensive checking of errors has not be done yet.
%}

%% ~Make other sections like Warning with \section{Warning }{....} ~

\seealso{
See \code{\link{data.cqc01}} for more examples which is are similar to the ones
in the ConQuest manual (Wu, Adams, Wilson & Haldane, 2007).

See \code{\link{tam.jml}} for joint maximum likelihood estimation.

Standard errors are estimated by a rather crude (but quick) approximation.
Use \code{\link{tam.se}} for improved standard errors.

For model comparisons see \code{\link{anova.tam}}.
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% EXAMPLES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\examples{
#############################################################################
# EXAMPLE 1: dichotomous data
# sim.rasch: 2000 persons, 40 items
#############################################################################
data(sim.rasch)

#***
# Rasch model (MML estimation)
mod1 <- tam.mml(resp=sim.rasch) 
# extract item parameters
mod1$item    # item difficulties

\dontrun{
# WLE estimation
wle1 <- tam.wle( mod1 )
# item fit
fit1 <- tam.fit(mod1)
# plausible value imputation
pv1 <- tam.pv(mod1)
# standard errors
se1 <- tam.se( mod1 )
# summary
summary(mod1)

#***
# Rasch model with fixed item difficulties from 'mod1'
xsi0 <- mod1$xsi$xsi
xsi.fixed <- cbind( 1:(length(xsi0)) , xsi0 )   
        # define vector with fixed item difficulties
mod1a <- tam.mml( resp=sim.rasch , xsi.fixed=xsi.fixed )
summary(mod1a)

# Rasch model with initial xsi parameters for items 2 (item difficulty b=-1.8),
# item 4 (b=-1.6) and item 40 (b=2)
xsi.inits <- cbind( c(2,4,40) , c(-1.8,-1.6,2))
mod1b <- tam.mml( resp=sim.rasch , xsi.inits=xsi.inits )

#***
# 1PL estimtaion with sum constraint on item difficulties
dat <- sim.rasch
# modify A design matrix to include the sum constraint
des <- designMatrices(resp=dat)
A1 <- des$A[ , , - ncol(dat) ]
A1[ ncol(dat) ,2 , ] <- 1
A1[,2,]
# estimate model
mod1c <- tam.mml( resp=dat , A=A1 , beta.fixed=FALSE , 
           control=list(fac.oldxsi=.1) ) 
summary(mod1c)

# estimate constraint='items' using tam.mml.mfr
formulaA= ~ 0 + item
mod1d <- tam.mml.mfr( resp=dat , formulaA=formulaA , 
                     control=list(fac.oldxsi=.1) , constraint="items") 
summary(mod1d)

# estimate constraint='items' using tam.mml.mfr
# long format response data
resp.long <- c(dat)

# pid and item facet specifications are necessary
#     Note, that we recommend the facet labels to be sortable in the same order that the
#     results are desired. 
#     compare to: facets <- data.frame( "item"=rep(colnames(dat), each=nrow(dat)) )
pid <- rep(1:nrow(dat), ncol(dat))
itemnames <- paste0("I", sprintf(paste('\%0', max(nchar(1:ncol(dat))), 'i', sep='' ), 
                    c(1:ncol(dat)) ) )
facets   <- data.frame( "item"=rep(itemnames, each=nrow(dat)) )

mod1d2 <- tam.mml.mfr( resp=resp.long , formulaA=formulaA , control=list(fac.oldxsi=.1) ,
                       constraint="items" , facets=facets , pid=pid) 
stopifnot( all(mod1d$xsi.facets$xsi == mod1d2$xsi.facets$xsi) )
}


#***
# 2PL model
mod2 <- tam.mml.2pl(resp=sim.rasch,irtmodel="2PL") 

# extract item parameters
mod2$xsi    # item difficulties
mod2$B      # item slopes

\dontrun{
# 2PL with fixed item difficulties and slopes from 'mod2'
xsi0 <- mod2$xsi$xsi
xsi.fixed <- cbind( 1:(length(xsi0)) , xsi0 )   
        # define vector with fixed item difficulties
mod2a <- tam.mml( resp=sim.rasch , xsi.fixed=xsi.fixed ,
        B = mod2$B # fix slopes
            )
summary(mod2a)
mod2a$B     # inspect used slope matrix

#****
# constrained 2PL estimation
# estimate item parameters in different slope groups
# items 1-10, 21-30 group 1
# items 11-20 group 2 and items 31-40 group 3
est.slope <- rep(1,40)
est.slope[ 11:20 ] <- 2
est.slope[ 31:40 ] <- 3
mod3 <- tam.mml.2pl( resp=sim.rasch , irtmodel="2PL.groups" , 
               est.slopegroups = est.slope )
mod3$B
summary(mod3)

#############################################################################
# SIMULATED EXAMPLE 2: Unidimensional calibration with latent regressors
#############################################################################

# (1) simulate data
set.seed(6778)     # set simulation seed
N <- 2000          # number of persons
# latent regressors Y
Y <- cbind( rnorm( N , sd = 1.5) , rnorm(N , sd = .3 ) )
# simulate theta
theta <- rnorm( N ) + .4 * Y[,1] + .2 * Y[,2]  # latent regression model
# number of items
I <- 40
p1 <- plogis( outer( theta , seq( -2 , 2 , len=I ) , "-" ) )
# simulate response matrix
resp <- 1 * ( p1 > matrix( runif( N*I ) , nrow=N , ncol=I ) )
colnames(resp) <- paste("I" , 1:I, sep="")
  
# (2) estimate model
mod2_1 <- tam(resp=resp , Y=Y)
summary(mod2_1)

# (3) setting initial values for beta coefficients
#   beta_2 = .20 , beta_3 = .35 for dimension 1
beta.inits <- cbind( c(2,3) , 1 , c(.2, .35 ) )
mod2_2 <- tam(resp=resp , Y=Y , beta.inits=beta.inits)

# (4) fix intercept to zero and third coefficient to .3
beta.fixed <- cbind( c(1,3) , 1 , c(0, .3 ) )
mod2_3 <- tam(resp=resp , Y=Y , beta.fixed=beta.fixed )

# (5) same model but with R regression formula for Y
dataY <- data.frame(Y)
colnames(dataY) <- c("Y1","Y2")
mod2_4 <- tam(resp=resp , dataY=dataY , formulaY = ~ Y1+Y2 )
summary(mod2_4)

# (6) model with interaction of regressors
mod2_5 <- tam(resp=resp , dataY=dataY , formulaY = ~ Y1*Y2 )
summary(mod2_5)

# (7) no constraint on regressors (removing constraint from intercept)
mod2_6 <- tam(resp=resp , Y=Y , beta.fixed=FALSE )

#############################################################################
# SIMULATED EXAMPLE 3: Multiple group estimation
#############################################################################

# (1) simulate data
set.seed(6778)
N <- 3000
theta <- c( rnorm(N/2,mean=0,sd = 1.5) , rnorm(N/2,mean=.5,sd = 1)  )
I <- 20
p1 <- plogis( outer( theta , seq( -2 , 2 , len=I ) , "-" ) )
resp <- 1 * ( p1 > matrix( runif( N*I ) , nrow=N , ncol=I ) )
colnames(resp) <- paste("I" , 1:I, sep="")
group <- rep(1:2 , each=N/2 )

# (2) estimate model
mod3_1 <- tam.mml( resp ,  group = group )
summary(mod3_1)

#############################################################################
# SIMULATED EXAMPLE 4: Multidimensional estimation
# with two dimensional theta's - simulate some bivariate data, 
# and regressors
# 40 items: first 20 items load on dimension 1, 
#           second 20 items load on dimension 2
#############################################################################

# (1) simulate some data
set.seed(6778)
library(mvtnorm)
N <- 1000      
Y <- cbind( rnorm( N ) , rnorm(N) )
theta <- rmvnorm( N,mean=c(0,0), sigma=matrix( c(1,.5,.5,1) , 2 , 2 ))
theta[,1] <- rnorm( N ) + .4 * Y[,1] + .2 * Y[,2]  # latent regression model
theta[,2] <- rnorm( N ) + .8 * Y[,1] + .5 * Y[,2]  # latent regression model
I <- 20
p1 <- plogis( outer( theta[,1] , seq( -2 , 2 , len=I ) , "-" ) )
resp1 <- 1 * ( p1 > matrix( runif( N*I ) , nrow=N , ncol=I ) )
p1 <- plogis( outer( theta[,2] , seq( -2 , 2 , len=I ) , "-" ) )
resp2 <- 1 * ( p1 > matrix( runif( N*I ) , nrow=N , ncol=I ) )
resp <- cbind(resp1,resp2)
colnames(resp) <- paste("I" , 1:(2*I), sep="")
  
# (2) define loading Matrix
Q <- array( 0 , dim = c( 2*I , 2 ))
Q[cbind(1:(2*I), c( rep(1,I) , rep(2,I) ))] <- 1

# (3) estimate models 

# Rasch model: without regressors
mod4_1 <- tam.mml( resp=resp , Q=Q )

# Rasch model: set covariance between dimensions to zero
variance_fixed <- cbind( 1 , 2 , 0 )
mod4_2 <- tam.mml( resp=resp , Q=Q , variance.fixed = variance_fixed )
summary(mod4_2)

# 2PL model
mod4_3 <- tam.mml.2pl( resp=resp , Q=Q , irtmodel="2PL" )

# Rasch model with 2000 quasi monte carlo nodes and a maximum of 15 iterations
# -> nodes are useful for more than 3 or 4 dimensions
mod4_4 <- tam.mml( resp=resp , Q=Q , control=list(snodes=2000,maxiter=15) )

# Rasch model with 2000 stochastic nodes
mod4_5 <- tam.mml( resp=resp, Q=Q,control=list(snodes=2000,QMC=FALSE,maxiter=15))

# estimate two dimensional Rasch model with regressors
mod4_6 <- tam.mml( resp=resp , Y=Y , Q=Q )

#############################################################################
# SIMULATED EXAMPLE 5: 2-dimensional estimation with within item dimensionality
#############################################################################
library(mvtnorm)
# (1) simulate data
set.seed(4762)
N <- 2000 # 2000 persons
Y <- rnorm( N )
theta <- rmvnorm( N,mean=c(0,0), sigma=matrix( c(1,.5,.5,1) , 2 , 2 ))
I <- 10
# 10 items load on the first dimension
p1 <- plogis( outer( theta[,1] , seq( -2 , 2 , len=I ) , "-" ) )
resp1 <- 1 * ( p1 > matrix( runif( N*I ) , nrow=N , ncol=I ) )
# 10 items load on the second dimension
p1 <- plogis( outer( theta[,2] , seq( -2 , 2 , len=I ) , "-" ) )
resp2 <- 1 * ( p1 > matrix( runif( N*I ) , nrow=N , ncol=I ) )
# 20 items load on both dimensions
p1 <- plogis( outer( 0.5*theta[,1] + 1.5*theta[,2] , seq( -2 , 2 , len=2*I ) , "-" ) )
resp3 <- 1 * ( p1 > matrix( runif( N*2*I ) , nrow=N , ncol=2*I ) )
#Combine the two sets of items into one response matrix
resp <- cbind(resp1, resp2, resp3 )
colnames(resp) <- paste("I" , 1:(4*I), sep="")

# (2) define loading matrix 
Q <- cbind(c(rep(1,10),rep(0,10),rep(1,20)), c(rep(0,10),rep(1,10),rep(1,20)))

# (3) model: within item dimensionality and 2PL estimation  
mod5 <- tam.mml.2pl(resp, Q=Q, irtmodel="2PL" , control=list(maxiter=20) )
summary(mod5)

# item difficulties
mod5$item
# item loadings
mod5$B

#############################################################################
# EXAMPLE 6: ordered data - Generalized partial credit model
#############################################################################
data( data.gpcm )

# Ex6.1: 2PL model
mod6_1 <- tam.mml.2pl( resp=data.gpcm , irtmodel="2PL" , control=list( maxiter=200) )
mod6_1$item # item intercepts
mod6_1$B    # for every category a separate slope parameter is estimated

# Ex6.2: Generalized partial credit model
mod6_2 <- tam.mml.2pl( resp= data.gpcm , irtmodel="GPCM" , control=list( maxiter=200) )
mod6_2$B    # joint slope parameter for all categories

# Ex6.3: some fixed entries of slope matrix B
# B: nitems x maxK x ndim  
#   ( number of items x maximum number of categories x number of dimensions)
# set two constraints
B.fixed <- matrix( 0 , 2 , 4 )
# set second item, score of 2 (category 3), at first dimension to 2.3
B.fixed[1,] <- c(2,3,1,2.3)
# set third item, score of 1 (category 2), at first dimension to 1.4
B.fixed[2,] <- c(3,2,1,1.4)

# estimate item parameter with variance fixed (by default)
mod6_3 <- tam.mml.2pl( resp=data.gpcm , irtmodel="2PL" , B.fixed = B.fixed , 
                 control=list( maxiter=200) )
mod6_3$B

# Ex 6.4: estimate the same model, but estimate variance
mod6_4 <- tam.mml.2pl( resp=data.gpcm , irtmodel="2PL" , B.fixed = B.fixed , 
               est.variance = TRUE , control=list( maxiter=350) )
mod6_4$B

# Ex 6.5: partial credit model
mod6_5 <- tam.mml( resp=data.gpcm ,control=list( maxiter=200) )
mod6_5$B

# Ex 6.6: partial credit model: Conquest parametrization 'item+item*step'
mod6_6 <- tam.mml( resp=data.gpcm , irtmodel="PCM2" )
summary(mod6_6)

# estimate mod6_6 applying the sum constraint of item difficulties
# modify design matrix of xsi paramters
A1 <- .A.PCM2(resp=data.gpcm )
A1[3,2:4,"Comfort"] <- 1:3
A1[3,2:4,"Work"] <- 1:3
A1 <- A1[ , , -3] # remove Benefit xsi item parameter
# estimate model
mod6_6b <- tam.mml( resp=data.gpcm , A=A1 , beta.fixed=FALSE )
summary(mod6_6b)

# estimate mod6_6 using tam.mml.mfr
mod6_6c <- tam.mml.mfr( resp=data.gpcm , formulaA= ~ 0 + item + item:step , 
    control=list(fac.oldxsi=.1)  , constraint="items" ) 
summary(mod6_6c)

# Ex 6.7: Rating scale model: Conquest parametrization 'item+step'
mod6_7 <- tam.mml( resp=data.gpcm , irtmodel="RSM" )
summary(mod6_7)

#############################################################################
# SIMULATED EXAMPLE 7: design matrix for slopes for the
#            generalized partial credit model
#############################################################################

# (1) simulate data from a model with a (item slope) design matrix E
set.seed(789)
I <- 42
b <- seq( -2 , 2 , len=I)
# create design matrix for loadings
E <- matrix( 0 , I , 5 )
E[ seq(1,I,3) , 1 ] <- 1
E[ seq(2,I,3) , 2 ] <- 1
E[ seq(3,I,3) , 3 ] <- 1
ind <- seq( 1, I , 2 ) ; E[ ind , 4 ] <- rep( c( .3 , -.2 ) , I )[ 1:length(ind) ]
ind <- seq( 2, I , 4 ) ; E[ ind , 5 ] <- rep( .15 , I )[ 1:length(ind) ]
E

# true basis slope parameters
lambda <- c( 1 , 1.2 , 0.8 , 1 , 1.1 )
# calculate item slopes
a <- E \%*\% lambda

N <- 4000
theta <- rnorm( N )
aM <- outer( rep(1,N) , a[,1] )
bM <- outer( rep(1,N) , b )
pM <- plogis( aM * ( matrix( theta , nrow=N , ncol=I  ) - bM ) )
dat <- 1 * ( pM > runif( N*I ) )
colnames(dat) <- paste("I" , 1:I , sep="")

mod7 <- tam.mml.2pl( resp = dat , irtmodel="GPCM.design" , E=E )
mod7$B

# recalculate estimated basis parameters
lm( mod7$B[,2,1] ~ 0+ as.matrix(E ) )
##   Call:
##   lm(formula = mod7$B[, 2, 1] ~ 0 + as.matrix(E))
##   Coefficients:
##   as.matrix(E)1  as.matrix(E)2  as.matrix(E)3  as.matrix(E)4  as.matrix(E)5  
##          0.9904         1.1896         0.7817         0.9601         1.2132  

#############################################################################
# EXAMPLE 8: Differential item functioning                                  #
#  A first example of a Multifaceted Rasch Model                            #
#  Facet is only female; 10 items are studied                               #
#############################################################################
data(data.ex08)

formulaA <- ~ item+female+item*female
# this formula is in R equivalent to 'item*female'
resp <- data.ex08[["resp"]]
facets <- as.data.frame( data.ex08[["facets"]] )

#***
# Model 8a: investigate gender DIF on all items
mod8a <- tam.mml.mfr( resp= resp , facets= facets , formulaA = formulaA )    
summary(mod8a)          

#***
# Model 8a 2: specification with long format response data
resp.long <- c( data.ex08[["resp"]] )
pid <- rep( 1:nrow(data.ex08[["resp"]]), ncol(data.ex08[["resp"]]) )

itemnames <- rep(colnames(data.ex08[["resp"]]), each=nrow(data.ex08[["resp"]]))
facets.long <- cbind( data.frame( "item"=itemnames ),
                 data.ex08[["facets"]][pid,,drop=F] )
                 
mod8a_2 <- tam.mml.mfr( resp=resp.long , facets=facets.long , formulaA=formulaA, pid= pid )    
stopifnot( all(mod8a$xsi.facets$xsi==mod8a_2$xsi.facets$xsi) )

#***
# Model 8b: Differential bundle functioning (DBF)
#   - investigate differential item functioning in item groups

# modify pre-specified design matrix to define 'appropriate' DBF effects
formulaA <- ~ item*female
des <- designMatrices.mfr( resp=resp , facets=facets , formulaA=formulaA)
A1 <- des$A$A.3d
# item group A: items 1-5
# item group B: items 6-8
# item group C: items 9-10
A1 <- A1[,,1:13]
dimnames(A1)[[3]][ c(12,13) ] <- c("A:female1" , "B:female1")
# item group A
A1[,2,12] <- 0
A1[c(1,5,7,9,11),2,12] <- -1
A1[c(1,5,7,9,11)+1,2,12] <- 1
# item group B
A1[,2,13] <- 0
A1[c(13,15,17),2,13] <- -1
A1[c(13,15,17)+1,2,13] <- 1
# item group C (define effect(A)+effect(B)+effect(C)=0)
A1[c(19,3),2,c(12,13)] <- 1
A1[c(19,3)+1,2,c(12,13)] <- -1
#   A1[,2,]   # look at modified design matrix
# estimate model
mod8b <- tam.mml( resp= des$gresp$gresp.noStep , A=A1 )
summary(mod8b)  

#############################################################################
# EXAMPLE 9: Multifaceted Rasch Model
#############################################################################
data(sim.mfr) ; data(sim.facets)

# two way interaction item and rater
formulaA <- ~item+item:step + item*rater
mod9a <- tam.mml.mfr( resp=sim.mfr , facets=sim.facets , formulaA = formulaA )
mod9a$xsi.facets
summary(mod9a)

# three way interaction item, female and rater
formulaA <- ~item+item:step + female*rater + female*item*step
mod9b <- tam.mml.mfr( resp=sim.mfr , facets=sim.facets , formulaA = formulaA )
summary(mod9b)

#############################################################################
# EXAMPLE 10: Model with raters.
#   Persons are arranged in multiple rows which is indicated
#   by multiple person identifiers.
#############################################################################
data(data.ex10)
dat <- data.ex10
head(dat)
##     pid rater I0001 I0002 I0003 I0004 I0005
## 1     1     1     0     1     1     0     0
## 451   1     2     1     1     1     1     0
## 901   1     3     1     1     1     0     1
## 452   2     2     1     1     1     0     1
## 902   2     3     1     1     0     1     1

facets <- dat[ , "rater" , drop=FALSE ] # define facet (rater)
pid <- dat$pid      # define person identifier (a person occurs multiple times)
resp <- dat[ , -c(1:2) ]        # item response data
formulaA <- ~ item * rater      # formula

mod10 <- tam.mml.mfr( resp=resp , facets=facets , formulaA = formulaA , pid=dat$pid )
summary(mod10)

# estimate person parameter with WLE 
wmod10 <- tam.wle( mod10 )

#***
# Model 10 2: specification with long format response data
resp.long=c(unlist( dat[ , -c(1:2) ] ))

pid <- rep( dat$pid, ncol(dat[ , -c(1:2) ]) )
itemnames <- rep(colnames(dat[ , -c(1:2) ]), each=nrow(dat[ , -c(1:2) ]))

# quick note: the 'trick' to use pid as the row index of the facet  (cf., used in Ex 8a_2)
# is not working here, since pid already occures multiple times in the original response data
facets <- cbind( data.frame("item"=itemnames),
                 dat[ rep(1:nrow(dat), ncol(dat[,-c(1:2)])), "rater" ,drop=F]
)

mod10_2 <- tam.mml.mfr( resp=resp.long , facets= facets , formulaA = formulaA, pid= pid )    

stopifnot( all(mod10$xsi.facets$xsi==mod10_2$xsi.facets$xsi) )

#############################################################################
# EXAMPLE 11: Dichotomous data with missing and omitted responses
#############################################################################
data(data.ex11) ; dat <- data.ex11

#***
# Model 11a: Calibration (item parameter estimating) in which omitted
#            responses (code 9) are set to missing
dat1 <- dat[,-1]
dat1[ dat1 == 9 ] <- NA
# estimate Rasch model
mod11a <- tam.mml( resp= dat1 )
summary(mod11a)
# compute person parameters
wmod11a <- tam.wle( mod11a )

#***
# Model 11b: Scaling persons (WLE estimation) setting omitted
#            responses as incorrect and using fixed
#            item parameters form Model 11a

# set matrix with fixed item difficulties as the input
xsi1 <- mod11a$xsi	# xsi output from Model 11a
xsi.fixed <- cbind( seq(1,nrow(xsi1) ) , xsi1$xsi )
# recode 9 to 0
dat2 <- dat[,-1]
dat2[ dat2 == 9 ] <- 0
# run Rasch model with fixed item difficulties
mod11b <- tam.mml( resp= dat2 , xsi.fixed=xsi.fixed )
summary(mod11b)
# WLE estimation
wmod11b <- tam.wle( mod11b )

#############################################################################
# EXAMPLE 12: Avoiding nonconvergence using the argument increment.factor
#############################################################################
data(data.ex12)
dat <- data.ex12

# non-convergence without increment.factor
mod1 <- tam.mml.2pl( resp=data.ex12 , control=list( maxiter=1000) )

# avoiding non-convergence with increment.factor=1.02
mod2 <- tam.mml.2pl( resp=data.ex12 , 
            control=list( maxiter=1000 , increment.factor=1.02) )
summary(mod1)
summary(mod2)

#############################################################################
# EXAMPLE 13: Longitudinal data 'data.long' from sirt package
#############################################################################
library(sirt)
data(data.long, package="sirt")
dat <- data.long
##   > colnames(dat)
##    [1] "idstud" "I1T1"   "I2T1"   "I3T1"   "I4T1"   "I5T1"   "I6T1"  
##    [8] "I3T2"   "I4T2"   "I5T2"   "I6T2"   "I7T2"   "I8T2"  

## item 1 to 6 administered at T1 and items 3 to 8 at T2
## items 3 to 6 are anchor items

#***
# Model 13a: 2-dimensional Rasch model assuming invariant item difficulties

# define matrix loadings
Q <- matrix(0,12,2)
colnames(Q) <- c("T1","T2")
Q[1:6,1] <- 1       # items at T1
Q[7:12,2] <- 1      # items at T2

# assume equal item difficulty of I3T1 and I3T2, I4T1 and I4T2, ...
# create draft design matrix and modify it
A <- designMatrices(resp=data.long[,-1])$A
dimnames(A)[[1]] <- colnames(data.long)[-1]
##   > str(A)
##    num [1:12, 1:2, 1:12] 0 0 0 0 0 0 0 0 0 0 ...
##    - attr(*, "dimnames")=List of 3
##     ..$ : chr [1:12] "Item01" "Item02" "Item03" "Item04" ...
##     ..$ : chr [1:2] "Category0" "Category1"
##     ..$ : chr [1:12] "I1T1" "I2T1" "I3T1" "I4T1" ...
A1 <- A[  ,  , c(1:6 , 11:12 ) ]
dimnames(A1)[[3]] <- substring( dimnames(A1)[[3]],1,2)
A1[7,2,3] <- -1     # difficulty(I3T1) = difficulty(I3T2)
A1[8,2,4] <- -1     # I4T1 = I4T2
A1[9,2,5] <- A1[10,2,6] <- -1
##   > A1[,2,]
##        I1 I2 I3 I4 I5 I6 I7 I8
##   I1T1 -1  0  0  0  0  0  0  0
##   I2T1  0 -1  0  0  0  0  0  0
##   I3T1  0  0 -1  0  0  0  0  0
##   I4T1  0  0  0 -1  0  0  0  0
##   I5T1  0  0  0  0 -1  0  0  0
##   I6T1  0  0  0  0  0 -1  0  0
##   I3T2  0  0 -1  0  0  0  0  0
##   I4T2  0  0  0 -1  0  0  0  0
##   I5T2  0  0  0  0 -1  0  0  0
##   I6T2  0  0  0  0  0 -1  0  0
##   I7T2  0  0  0  0  0  0 -1  0
##   I8T2  0  0  0  0  0  0  0 -1

# estimate model
# set intercept of second dimension (T2) to zero
beta.fixed <- cbind( 1 , 2 , 0 )
mod13a <- tam.mml( resp=data.long[,-1] , Q=Q , A=A1 , beta.fixed=beta.fixed)
summary(mod13a)

#***
# Model 13b: invariant item difficulties with zero mean item difficulty
#           of anchor items

A <- designMatrices(resp=data.long[,-1])$A
dimnames(A)[[1]] <- colnames(data.long)[-1]
A1 <- A[  ,  , c(1:5 , 11:12 ) ]
dimnames(A1)[[3]] <- substring( dimnames(A1)[[3]],1,2)
A1[7,2,3] <- -1     # difficulty(I3T1) = difficulty(I3T2)
A1[8,2,4] <- -1     # I4T1 = I4T2
A1[9,2,5] <- -1
A1[6,2,3] <- A1[6,2,4] <- A1[6,2,5] <- 1  # I6T1=-(I3T1+I4T1+I5T1)
A1[10,2,3] <- A1[10,2,4] <- A1[10,2,5] <- 1  # I6T2=-(I3T2+I4T2+I5T2)
A1[,2,]
##      I1 I2 I3 I4 I5 I7 I8
## I1T1 -1  0  0  0  0  0  0
## I2T1  0 -1  0  0  0  0  0
## I3T1  0  0 -1  0  0  0  0
## I4T1  0  0  0 -1  0  0  0
## I5T1  0  0  0  0 -1  0  0
## I6T1  0  0  1  1  1  0  0
## I3T2  0  0 -1  0  0  0  0
## I4T2  0  0  0 -1  0  0  0
## I5T2  0  0  0  0 -1  0  0
## I6T2  0  0  1  1  1  0  0
## I7T2  0  0  0  0  0 -1  0
## I8T2  0  0  0  0  0  0 -1

mod13b <- tam.mml( resp=data.long[,-1] , Q=Q , A=A1 , beta.fixed=FALSE)
summary(mod13b)

#############################################################################
# EXAMPLE 14: Facet model with latent regression
#############################################################################
data( data.ex14 )
dat <- data.ex14

#***
# Model 14a: facet model
resp <- dat[ , paste0("crit",1:7,sep="") ]	# item data
facets <- data.frame( "rater" = dat$rater )     # define facets
formulaA <- ~item+item*step + rater
mod14a <- tam.mml.mfr( resp , facets=facets , formulaA=formulaA , pid=dat$pid )
summary(mod14a)

#***
# Model 14b: facet model with latent regression
#   Note that dataY must correspond to rows in resp and facets which means
#   that there must be the same rows in Y for a person with multiple rows
#   in resp
dataY <- dat[ , c("X1","X2") ]		# latent regressors
formulaY <- ~ X1+X2			# latent regression formula
mod14b <- tam.mml.mfr( resp , facets=facets , formulaA= formulaA ,
            dataY=dataY , formulaY=formulaY , pid=dat$pid)
summary(mod14b)

#***
# Model 14c: Multi-facet model with item slope estimation
# use design matrix and modified response data from Model 1
# item-specific slopes

resp1 <- mod14a$resp      # extract response data with generalized items
A <- mod14a$A             # extract design matrix for item intercepts
colnames(resp1)

# define design matrix for slopes
E <- matrix( 0 , nrow= ncol(resp1) , ncol=7 )
colnames(E) <- paste0("crit",1:7)
rownames(E) <- colnames(resp1)
E[ cbind( 1:(7*7) , rep(1:7,each=7) ) ] <- 1

mod14c <- tam.mml.2pl( resp=resp1 , A=A , irtmodel="GPCM.design" , E=E ,
        control=list(maxiter=100) )
summary(mod14c)

#############################################################################
# EXAMPLE 15: Coping with nonconvergent models
#############################################################################

data(data.ex15)
data <- data.ex15
# facet model 'group*item' is of interest

#***
# Model 15a: 
mod15a <- tam.mml.mfr(resp = data[,-c(1:2)],facets=data[,"group",drop=FALSE], 
    formulaA = ~ item + group*item , pid = data$pid , control=list(maxiter=50))
## See output:
## 
##   Iteration 47     2013-09-10 16:51:39
##   E Step
##   M Step Intercepts   |----
##     Deviance = 75510.2868 | Deviance change: -595.0609
##   !!! Deviance increases!                                        !!!!
##   !!! Choose maybe fac.oldxsi > 0 and/or increment.factor > 1    !!!!
##     Maximum intercept parameter change: 0.925045
##     Maximum regression parameter change: 0
##     Variance:  0.9796  | Maximum change: 0.009226

#***
# Model 15b: Follow the suggestions of changing the default of fac.oldxsi and 
#            increment.factor 
mod15b <- tam.mml.mfr(resp = data[,-c(1:2)],facets=data[,"group",drop=FALSE], 
            formulaA = ~ group*item , pid = data$pid ,
            control=list(maxiter= 50 , increment.factor=1.03 , fac.oldxsi=.4 ) )
}
}
% Add one or more standard keywords, see file 'KEYWORDS' in the
% R documentation directory.
\keyword{Marginal maximum likelihood estimation (MML)}
\keyword{Multidimensional item response model}
\keyword{summary}